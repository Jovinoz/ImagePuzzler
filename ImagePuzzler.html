<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ImagePuzzler</title>
    <style>
/* Reset and Base Styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    color: #333;
}

/* App Container */
.app-container {
    max-width: 1600px;
    margin: 0 auto;
    padding: 20px;
}

/* Header */
.header {
    text-align: center;
    padding: 20px 0 30px;
}

.header-title {
    font-size: 3rem;
    font-weight: 700;
    color: white;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
}

#project-name-display:not(:empty)::before {
    content: ' - ';
}

/* Cards */
.card {
    background: white;
    border-radius: 16px;
    padding: 24px;
    margin-bottom: 20px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
}

.card-heading {
    color: #667eea;
    font-size: 1.25rem;
    font-weight: 600;
    margin-bottom: 16px;
}

/* Gallery */
.gallery-container {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    min-height: 120px;
    padding: 16px;
    border: 2px dashed #ccc;
    border-radius: 8px;
    transition: border-color 0.2s, background-color 0.2s;
}

.gallery-container.drag-over {
    border-color: #667eea;
    background-color: rgba(102, 126, 234, 0.1);
}

.thumbnail {
    width: 100px;
    height: 100px;
    border-radius: 8px;
    border: 3px solid #ccc;
    overflow: hidden;
    position: relative;
    cursor: pointer;
    transition: border-color 0.2s, box-shadow 0.2s;
    background: #f5f5f5;
}

.thumbnail:hover {
    border-color: #999;
}

.thumbnail.active {
    border-color: #667eea;
    box-shadow: 0 0 12px rgba(102, 126, 234, 0.5);
}

.thumbnail.dragging {
    opacity: 0.5;
}

.thumbnail img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.thumbnail-number {
    position: absolute;
    top: 4px;
    left: 4px;
    background: rgba(0, 0, 0, 0.7);
    color: white;
    font-size: 12px;
    font-weight: 600;
    padding: 2px 6px;
    border-radius: 4px;
}

.thumbnail-delete {
    position: absolute;
    top: 4px;
    right: 4px;
    background: rgba(220, 53, 69, 0.9);
    color: white;
    border: none;
    width: 22px;
    height: 22px;
    border-radius: 50%;
    cursor: pointer;
    font-size: 14px;
    line-height: 1;
    opacity: 0;
    transition: opacity 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
}

.thumbnail:hover .thumbnail-delete {
    opacity: 1;
}

.thumbnail-caption {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: rgba(0, 0, 0, 0.7);
    color: white;
    font-size: 10px;
    padding: 4px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.add-image-card {
    width: 100px;
    height: 100px;
    border: 2px dashed #667eea;
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    transition: background 0.2s, border-color 0.2s;
}

.add-image-card:hover {
    background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
    border-color: #764ba2;
}

.add-icon {
    font-size: 32px;
    color: #667eea;
    line-height: 1;
}

.add-text {
    font-size: 12px;
    color: #667eea;
    margin-top: 4px;
}

/* Main Content Layout */
.main-content {
    display: flex;
    gap: 20px;
}

@media (max-width: 1200px) {
    .main-content {
        flex-direction: column;
    }
}

/* Canvas Area */
.canvas-card {
    flex: 1;
    min-width: 0;
}

.canvas-container {
    position: relative;
    background: #1a1a2e;
    border-radius: 8px;
    min-height: 400px;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
}

#editor-canvas {
    max-width: 100%;
    max-height: 600px;
    cursor: crosshair;
    display: none;
}

#editor-canvas.visible {
    display: block;
}

.empty-state {
    color: #888;
    font-size: 1.25rem;
    text-align: center;
    padding: 40px;
}

.answer-overlay {
    position: absolute;
    cursor: move;
    user-select: none;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
    display: none;
    white-space: nowrap;
}

.answer-overlay.visible {
    display: block;
}

/* Controls Panel */
.controls-card {
    width: 350px;
    flex-shrink: 0;
}

@media (max-width: 1200px) {
    .controls-card {
        width: 100%;
    }
}

.control-section {
    margin-bottom: 20px;
    padding-bottom: 20px;
    border-bottom: 1px solid #eee;
}

.control-section:last-child {
    margin-bottom: 0;
    padding-bottom: 0;
    border-bottom: none;
}

.instructions {
    color: #666;
    font-style: italic;
    font-size: 0.9rem;
}

.control-label {
    display: block;
    font-weight: 600;
    color: #444;
    margin-bottom: 6px;
}

.control-label.small {
    font-size: 0.85rem;
    margin-top: 12px;
}

.text-input {
    width: 100%;
    padding: 10px 12px;
    border: 2px solid #ddd;
    border-radius: 8px;
    font-size: 1rem;
    transition: border-color 0.2s;
}

.text-input:focus {
    outline: none;
    border-color: #667eea;
}

.textarea {
    resize: vertical;
    min-height: 80px;
}

.number-input {
    width: 80px;
    padding: 8px 10px;
    border: 2px solid #ddd;
    border-radius: 8px;
    font-size: 1rem;
}

.number-input:focus {
    outline: none;
    border-color: #667eea;
}

.color-input {
    width: 60px;
    height: 36px;
    padding: 2px;
    border: 2px solid #ddd;
    border-radius: 8px;
    cursor: pointer;
}

.checkbox-label {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-top: 12px;
    cursor: pointer;
    font-size: 0.9rem;
    color: #555;
}

.checkbox-label input {
    width: 18px;
    height: 18px;
    cursor: pointer;
}

/* Buttons */
.btn {
    padding: 12px 24px;
    border: none;
    border-radius: 8px;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: transform 0.1s, box-shadow 0.2s;
    width: 100%;
}

.btn:hover {
    transform: translateY(-1px);
}

.btn:active {
    transform: translateY(0);
}

.btn-primary {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
}

.btn-primary:hover {
    box-shadow: 0 6px 16px rgba(102, 126, 234, 0.5);
}

.btn-secondary {
    background: #f8f9fa;
    color: #667eea;
    border: 2px solid #667eea;
}

.btn-secondary:hover {
    background: #e9ecef;
}

.btn-danger {
    background: #dc3545;
    color: white;
}

.btn-danger:hover {
    background: #c82333;
}

.full-width {
    width: 100%;
}

/* Settings Card */
.settings-card {
    max-width: 800px;
    margin-left: auto;
    margin-right: auto;
}

.divider {
    border: none;
    border-top: 1px solid #eee;
    margin: 20px 0;
}

.settings-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 16px;
}

@media (max-width: 600px) {
    .settings-grid {
        grid-template-columns: 1fr;
    }
}

.setting-item.full-width {
    grid-column: 1 / -1;
}

/* Modal */
.modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.95);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 1000;
}

.modal.visible {
    display: flex;
}

.modal-close {
    position: absolute;
    top: 20px;
    right: 20px;
    background: none;
    border: none;
    color: white;
    font-size: 40px;
    cursor: pointer;
    opacity: 0.7;
    transition: opacity 0.2s;
    z-index: 1001;
}

.modal-close:hover {
    opacity: 1;
}

.preview-container {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}

.preview-cropped {
    transition: transform 1.2s ease-in-out;
}

.preview-question {
    color: white;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
    margin-top: 20px;
    transition: opacity 0.4s;
}

.preview-full-image {
    position: absolute;
    opacity: 0;
    transition: opacity 1s;
}

.preview-answer {
    position: absolute;
    opacity: 0;
    transition: opacity 0.8s;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
}

.preview-instruction {
    position: absolute;
    bottom: 40px;
    color: white;
    font-size: 1.25rem;
    opacity: 0.8;
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0%, 100% { opacity: 0.6; }
    50% { opacity: 1; }
}

/* Utility classes */
.hidden {
    display: none !important;
}
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <header class="header">
            <h1 class="header-title">ImagePuzzler<span id="project-name-display"></span></h1>
        </header>

        <!-- Thumbnail Gallery -->
        <section class="card gallery-card">
            <h2 class="card-heading">Images (<span id="image-count">0</span>)</h2>
            <div class="gallery-container" id="gallery-container">
                <div class="add-image-card" id="add-image-card">
                    <span class="add-icon">+</span>
                    <span class="add-text">Add Image</span>
                </div>
            </div>
            <input type="file" id="file-input" accept="image/*" multiple hidden>
        </section>

        <!-- Main Content Area -->
        <div class="main-content">
            <!-- Canvas Area -->
            <section class="card canvas-card" id="canvas-section">
                <div class="canvas-container" id="canvas-container">
                    <div class="empty-state" id="empty-state">
                        <p>Add images to get started</p>
                    </div>
                    <canvas id="editor-canvas"></canvas>
                    <div class="answer-overlay" id="answer-overlay"></div>
                </div>
            </section>

            <!-- Controls Panel -->
            <section class="card controls-card" id="controls-section">
                <div class="control-section">
                    <p class="instructions">Click and drag on the image to select a region</p>
                </div>

                <div class="control-section">
                    <label class="control-label">Question</label>
                    <input type="text" id="question-input" class="text-input" placeholder="Enter question text">
                    <label class="control-label small">Size</label>
                    <input type="number" id="question-size" class="number-input" value="72" min="10" max="200">
                </div>

                <div class="control-section">
                    <label class="control-label">Answer</label>
                    <input type="text" id="answer-input" class="text-input" placeholder="Enter answer text">
                    <label class="control-label small">Size</label>
                    <input type="number" id="answer-size" class="number-input" value="72" min="10" max="200">
                    <label class="control-label small">Color</label>
                    <input type="color" id="answer-color" class="color-input" value="#ffffff">
                    <label class="checkbox-label">
                        <input type="checkbox" id="answer-outline" checked>
                        Add outline (better visibility)
                    </label>
                </div>

                <div class="control-section">
                    <button class="btn btn-secondary" id="preview-btn">Preview Game Animation</button>
                </div>

                <div class="control-section">
                    <button class="btn btn-primary" id="save-project-btn">Save Project</button>
                </div>

                <div class="control-section">
                    <button class="btn btn-primary" id="generate-game-btn">Generate Playable Game</button>
                </div>

                <div class="control-section">
                    <button class="btn btn-danger" id="reset-btn">Reset All</button>
                </div>
            </section>
        </div>

        <!-- Project Settings -->
        <section class="card settings-card">
            <button class="btn btn-secondary full-width" id="load-project-btn">Load Project</button>
            <input type="file" id="load-project-input" accept=".zip" hidden>

            <hr class="divider">

            <div class="settings-grid">
                <div class="setting-item">
                    <label class="control-label">Project Name</label>
                    <input type="text" id="project-name" class="text-input" placeholder="My Quiz Project">
                </div>

                <div class="setting-item">
                    <label class="control-label">Game Title</label>
                    <input type="text" id="game-title" class="text-input" placeholder="Uses project name if empty">
                </div>

                <div class="setting-item full-width">
                    <label class="control-label">Explanation</label>
                    <textarea id="game-explanation" class="text-input textarea" placeholder="Instructions shown on game's title page"></textarea>
                </div>

                <div class="setting-item">
                    <label class="control-label">Next Button Label</label>
                    <input type="text" id="next-button-label" class="text-input" placeholder="Leave empty to click anywhere">
                </div>

                <div class="setting-item">
                    <label class="control-label">Progress Label</label>
                    <input type="text" id="progress-label" class="text-input" placeholder="Slide {current} of {total}">
                </div>

                <div class="setting-item full-width">
                    <label class="control-label">Completion Message</label>
                    <input type="text" id="completion-message" class="text-input" placeholder="Congratulations! You've completed the quiz.">
                </div>
            </div>
        </section>
    </div>

    <!-- Preview Modal -->
    <div class="modal" id="preview-modal">
        <button class="modal-close" id="modal-close">&times;</button>
        <div class="preview-container" id="preview-container"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
// ImagePuzzler Builder Application

class ImagePuzzler {
    constructor() {
        this.images = [];
        this.currentIndex = -1;
        this.isDragging = false;
        this.isDrawing = false;
        this.dragStart = { x: 0, y: 0 };
        this.answerPosition = { x: 50, y: 50 };

        this.initElements();
        this.initEventListeners();
        this.updateUI();
    }

    initElements() {
        // Gallery
        this.galleryContainer = document.getElementById('gallery-container');
        this.addImageCard = document.getElementById('add-image-card');
        this.fileInput = document.getElementById('file-input');
        this.imageCount = document.getElementById('image-count');

        // Canvas
        this.canvasSection = document.getElementById('canvas-section');
        this.canvasContainer = document.getElementById('canvas-container');
        this.canvas = document.getElementById('editor-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.emptyState = document.getElementById('empty-state');
        this.answerOverlay = document.getElementById('answer-overlay');

        // Controls
        this.questionInput = document.getElementById('question-input');
        this.questionSize = document.getElementById('question-size');
        this.answerInput = document.getElementById('answer-input');
        this.answerSize = document.getElementById('answer-size');
        this.answerColor = document.getElementById('answer-color');
        this.answerOutline = document.getElementById('answer-outline');

        // Buttons
        this.previewBtn = document.getElementById('preview-btn');
        this.saveProjectBtn = document.getElementById('save-project-btn');
        this.generateGameBtn = document.getElementById('generate-game-btn');
        this.resetBtn = document.getElementById('reset-btn');
        this.loadProjectBtn = document.getElementById('load-project-btn');
        this.loadProjectInput = document.getElementById('load-project-input');

        // Settings
        this.projectName = document.getElementById('project-name');
        this.projectNameDisplay = document.getElementById('project-name-display');
        this.gameTitle = document.getElementById('game-title');
        this.gameExplanation = document.getElementById('game-explanation');
        this.nextButtonLabel = document.getElementById('next-button-label');
        this.progressLabel = document.getElementById('progress-label');
        this.completionMessage = document.getElementById('completion-message');

        // Modal
        this.previewModal = document.getElementById('preview-modal');
        this.modalClose = document.getElementById('modal-close');
        this.previewContainer = document.getElementById('preview-container');
    }

    initEventListeners() {
        // File input
        this.addImageCard.addEventListener('click', () => this.fileInput.click());
        this.fileInput.addEventListener('change', (e) => this.handleFiles(e.target.files));

        // Drag and drop on gallery
        this.galleryContainer.addEventListener('dragover', (e) => {
            e.preventDefault();
            this.galleryContainer.classList.add('drag-over');
        });
        this.galleryContainer.addEventListener('dragleave', () => {
            this.galleryContainer.classList.remove('drag-over');
        });
        this.galleryContainer.addEventListener('drop', (e) => {
            e.preventDefault();
            this.galleryContainer.classList.remove('drag-over');
            this.handleFiles(e.dataTransfer.files);
        });

        // Canvas events
        this.canvas.addEventListener('mousedown', (e) => this.startDrawing(e));
        this.canvas.addEventListener('mousemove', (e) => this.draw(e));
        this.canvas.addEventListener('mouseup', () => this.stopDrawing());
        this.canvas.addEventListener('mouseleave', () => this.stopDrawing());

        // Touch events for canvas
        this.canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.startDrawing(e.touches[0]);
        });
        this.canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            this.draw(e.touches[0]);
        });
        this.canvas.addEventListener('touchend', () => this.stopDrawing());

        // Answer overlay drag
        this.answerOverlay.addEventListener('mousedown', (e) => this.startDraggingAnswer(e));
        document.addEventListener('mousemove', (e) => this.dragAnswer(e));
        document.addEventListener('mouseup', () => this.stopDraggingAnswer());

        // Control inputs
        this.questionInput.addEventListener('input', () => this.updateCurrentImage());
        this.questionSize.addEventListener('input', () => this.updateCurrentImage());
        this.answerInput.addEventListener('input', () => this.updateCurrentImage());
        this.answerSize.addEventListener('input', () => this.updateCurrentImage());
        this.answerColor.addEventListener('input', () => this.updateCurrentImage());
        this.answerOutline.addEventListener('change', () => this.updateCurrentImage());

        // Buttons
        this.previewBtn.addEventListener('click', () => this.showPreview());
        this.saveProjectBtn.addEventListener('click', () => this.saveProject());
        this.generateGameBtn.addEventListener('click', () => this.generateGame());
        this.resetBtn.addEventListener('click', () => this.resetAll());
        this.loadProjectBtn.addEventListener('click', () => this.loadProjectInput.click());
        this.loadProjectInput.addEventListener('change', (e) => this.loadProject(e.target.files[0]));

        // Settings
        this.projectName.addEventListener('input', () => this.updateProjectName());

        // Modal
        this.modalClose.addEventListener('click', () => this.closePreview());
        this.previewModal.addEventListener('click', (e) => {
            if (e.target === this.previewModal) this.closePreview();
        });
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') this.closePreview();
        });
    }

    handleFiles(files) {
        const imageFiles = Array.from(files).filter(f => f.type.startsWith('image/'));

        imageFiles.forEach(file => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    this.images.push({
                        id: Date.now() + Math.random(),
                        name: file.name,
                        dataUrl: e.target.result,
                        width: img.width,
                        height: img.height,
                        selection: null,
                        question: '',
                        questionSize: 72,
                        answer: '',
                        answerSize: 72,
                        answerColor: '#ffffff',
                        answerOutline: true,
                        answerPosition: { x: 50, y: 50 }
                    });

                    if (this.currentIndex === -1) {
                        this.currentIndex = 0;
                    }

                    this.updateUI();
                    this.renderGallery();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });

        this.fileInput.value = '';
    }

    renderGallery() {
        // Remove existing thumbnails
        const thumbnails = this.galleryContainer.querySelectorAll('.thumbnail');
        thumbnails.forEach(t => t.remove());

        // Add thumbnails
        this.images.forEach((image, index) => {
            const thumb = document.createElement('div');
            thumb.className = 'thumbnail' + (index === this.currentIndex ? ' active' : '');
            thumb.draggable = true;
            thumb.dataset.index = index;

            thumb.innerHTML = `
                <img src="${image.dataUrl}" alt="Image ${index + 1}">
                <span class="thumbnail-number">${index + 1}</span>
                <button class="thumbnail-delete">&times;</button>
                ${image.question ? `<span class="thumbnail-caption">${image.question}</span>` : ''}
            `;

            // Click to select
            thumb.addEventListener('click', (e) => {
                if (!e.target.classList.contains('thumbnail-delete')) {
                    this.selectImage(index);
                }
            });

            // Delete button
            thumb.querySelector('.thumbnail-delete').addEventListener('click', (e) => {
                e.stopPropagation();
                this.deleteImage(index);
            });

            // Drag events for reordering
            thumb.addEventListener('dragstart', (e) => {
                thumb.classList.add('dragging');
                e.dataTransfer.setData('text/plain', index);
                e.dataTransfer.effectAllowed = 'move';
            });

            thumb.addEventListener('dragend', () => {
                thumb.classList.remove('dragging');
            });

            thumb.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            });

            thumb.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                const fromIndex = parseInt(e.dataTransfer.getData('text/plain'));
                const toIndex = index;
                if (fromIndex !== toIndex && !isNaN(fromIndex)) {
                    this.reorderImages(fromIndex, toIndex);
                }
            });

            this.galleryContainer.insertBefore(thumb, this.addImageCard);
        });

        this.imageCount.textContent = this.images.length;
    }

    selectImage(index) {
        this.currentIndex = index;
        this.updateUI();
        this.renderGallery();
    }

    deleteImage(index) {
        this.images.splice(index, 1);

        if (this.images.length === 0) {
            this.currentIndex = -1;
        } else if (this.currentIndex >= this.images.length) {
            this.currentIndex = this.images.length - 1;
        }

        this.updateUI();
        this.renderGallery();
    }

    reorderImages(fromIndex, toIndex) {
        const [image] = this.images.splice(fromIndex, 1);
        this.images.splice(toIndex, 0, image);

        if (this.currentIndex === fromIndex) {
            this.currentIndex = toIndex;
        } else if (fromIndex < this.currentIndex && toIndex >= this.currentIndex) {
            this.currentIndex--;
        } else if (fromIndex > this.currentIndex && toIndex <= this.currentIndex) {
            this.currentIndex++;
        }

        this.renderGallery();
    }

    updateUI() {
        const hasImage = this.currentIndex >= 0 && this.images[this.currentIndex];

        this.emptyState.style.display = hasImage ? 'none' : 'block';
        this.canvas.classList.toggle('visible', hasImage);
        this.answerOverlay.classList.toggle('visible', false);

        if (hasImage) {
            const image = this.images[this.currentIndex];
            this.loadImageToCanvas(image);

            this.questionInput.value = image.question || '';
            this.questionSize.value = image.questionSize || 72;
            this.answerInput.value = image.answer || '';
            this.answerSize.value = image.answerSize || 72;
            this.answerColor.value = image.answerColor || '#ffffff';
            this.answerOutline.checked = image.answerOutline !== false;
            this.answerPosition = image.answerPosition || { x: 50, y: 50 };
        } else {
            this.questionInput.value = '';
            this.answerInput.value = '';
        }
    }

    loadImageToCanvas(image) {
        const img = new Image();
        img.onload = () => {
            // Calculate canvas size to fit container
            const container = this.canvasContainer;
            const maxWidth = container.clientWidth - 40;
            const maxHeight = 600;

            let width = img.width;
            let height = img.height;

            if (width > maxWidth) {
                height = height * (maxWidth / width);
                width = maxWidth;
            }
            if (height > maxHeight) {
                width = width * (maxHeight / height);
                height = maxHeight;
            }

            this.canvas.width = width;
            this.canvas.height = height;
            this.canvas.dataset.scale = width / img.width;

            this.redrawCanvas();
        };
        img.src = image.dataUrl;
    }

    redrawCanvas() {
        const image = this.images[this.currentIndex];
        if (!image) return;

        const img = new Image();
        img.onload = () => {
            const scale = parseFloat(this.canvas.dataset.scale) || 1;

            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.drawImage(img, 0, 0, this.canvas.width, this.canvas.height);

            // Draw selection rectangle
            if (image.selection) {
                const sel = image.selection;
                this.ctx.strokeStyle = '#3498db';
                this.ctx.lineWidth = 2;
                this.ctx.fillStyle = 'rgba(52, 152, 219, 0.2)';

                this.ctx.fillRect(
                    sel.x * scale,
                    sel.y * scale,
                    sel.width * scale,
                    sel.height * scale
                );
                this.ctx.strokeRect(
                    sel.x * scale,
                    sel.y * scale,
                    sel.width * scale,
                    sel.height * scale
                );
            }

            // Update answer overlay
            if (image.answer) {
                this.answerOverlay.textContent = image.answer;
                this.answerOverlay.style.fontSize = `${image.answerSize * scale}px`;
                this.answerOverlay.style.color = image.answerColor;
                this.answerOverlay.style.webkitTextStroke = image.answerOutline ? '2px black' : 'none';
                this.answerOverlay.style.left = `${this.answerPosition.x}%`;
                this.answerOverlay.style.top = `${this.answerPosition.y}%`;
                this.answerOverlay.style.transform = 'translate(-50%, -50%)';
                this.answerOverlay.classList.add('visible');
            } else {
                this.answerOverlay.classList.remove('visible');
            }
        };
        img.src = image.dataUrl;
    }

    startDrawing(e) {
        this.isDrawing = true;
        const rect = this.canvas.getBoundingClientRect();
        const scale = parseFloat(this.canvas.dataset.scale) || 1;

        this.dragStart = {
            x: (e.clientX - rect.left) / scale,
            y: (e.clientY - rect.top) / scale
        };
    }

    draw(e) {
        if (!this.isDrawing) return;

        const image = this.images[this.currentIndex];
        if (!image) return;

        const rect = this.canvas.getBoundingClientRect();
        const scale = parseFloat(this.canvas.dataset.scale) || 1;

        const currentX = (e.clientX - rect.left) / scale;
        const currentY = (e.clientY - rect.top) / scale;

        image.selection = {
            x: Math.min(this.dragStart.x, currentX),
            y: Math.min(this.dragStart.y, currentY),
            width: Math.abs(currentX - this.dragStart.x),
            height: Math.abs(currentY - this.dragStart.y)
        };

        this.redrawCanvas();
    }

    stopDrawing() {
        this.isDrawing = false;
    }

    startDraggingAnswer(e) {
        e.preventDefault();
        this.isDragging = true;
    }

    dragAnswer(e) {
        if (!this.isDragging) return;

        const rect = this.canvasContainer.getBoundingClientRect();
        const x = ((e.clientX - rect.left) / rect.width) * 100;
        const y = ((e.clientY - rect.top) / rect.height) * 100;

        this.answerPosition = {
            x: Math.max(0, Math.min(100, x)),
            y: Math.max(0, Math.min(100, y))
        };

        this.updateCurrentImage();
        this.redrawCanvas();
    }

    stopDraggingAnswer() {
        this.isDragging = false;
    }

    updateCurrentImage() {
        const image = this.images[this.currentIndex];
        if (!image) return;

        image.question = this.questionInput.value;
        image.questionSize = parseInt(this.questionSize.value) || 72;
        image.answer = this.answerInput.value;
        image.answerSize = parseInt(this.answerSize.value) || 72;
        image.answerColor = this.answerColor.value;
        image.answerOutline = this.answerOutline.checked;
        image.answerPosition = { ...this.answerPosition };

        this.redrawCanvas();
        this.renderGallery();
    }

    updateProjectName() {
        const name = this.projectName.value;
        this.projectNameDisplay.textContent = name;
        document.title = name ? `ImagePuzzler - ${name}` : 'ImagePuzzler';
    }

    showPreview() {
        const image = this.images[this.currentIndex];
        if (!image || !image.selection) {
            alert('Please select an image and draw a selection rectangle first.');
            return;
        }

        this.previewModal.classList.add('visible');
        this.renderPreview(image);
    }

    renderPreview(image) {
        this.previewContainer.innerHTML = '';

        const sel = image.selection;
        const img = new Image();
        img.src = image.dataUrl;

        img.onload = () => {
            // Create cropped canvas
            const croppedCanvas = document.createElement('canvas');
            croppedCanvas.width = sel.width;
            croppedCanvas.height = sel.height;
            const croppedCtx = croppedCanvas.getContext('2d');
            croppedCtx.drawImage(img, sel.x, sel.y, sel.width, sel.height, 0, 0, sel.width, sel.height);

            // Calculate display sizes
            const maxSize = Math.min(window.innerWidth * 0.75, window.innerHeight * 0.6);
            const croppedScale = Math.min(maxSize / sel.width, maxSize / sel.height, 1);

            const displayWidth = sel.width * croppedScale;
            const displayHeight = sel.height * croppedScale;

            // Cropped image element
            const croppedImg = document.createElement('img');
            croppedImg.src = croppedCanvas.toDataURL();
            croppedImg.className = 'preview-cropped';
            croppedImg.style.width = displayWidth + 'px';
            croppedImg.style.height = displayHeight + 'px';
            croppedImg.style.opacity = '0';

            // Question text
            const questionEl = document.createElement('div');
            questionEl.className = 'preview-question';
            questionEl.textContent = image.question || 'What is this?';
            questionEl.style.fontSize = (image.questionSize * croppedScale) + 'px';
            questionEl.style.opacity = '0';

            // Full image (hidden initially)
            const fullImg = document.createElement('img');
            fullImg.src = image.dataUrl;
            fullImg.className = 'preview-full-image';

            const fullScale = Math.min(
                (window.innerWidth * 0.9) / img.width,
                (window.innerHeight * 0.9) / img.height,
                1
            );
            fullImg.style.width = (img.width * fullScale) + 'px';
            fullImg.style.height = (img.height * fullScale) + 'px';

            // Answer text
            const answerEl = document.createElement('div');
            answerEl.className = 'preview-answer';
            answerEl.textContent = image.answer || 'Answer';
            answerEl.style.fontSize = (image.answerSize * fullScale) + 'px';
            answerEl.style.color = image.answerColor;
            if (image.answerOutline) {
                answerEl.style.webkitTextStroke = '2px black';
            }
            answerEl.style.left = image.answerPosition.x + '%';
            answerEl.style.top = image.answerPosition.y + '%';
            answerEl.style.transform = 'translate(-50%, -50%)';

            // Instruction
            const instruction = document.createElement('div');
            instruction.className = 'preview-instruction';
            instruction.textContent = 'Click to reveal';

            // Add elements
            this.previewContainer.appendChild(fullImg);
            this.previewContainer.appendChild(croppedImg);
            this.previewContainer.appendChild(questionEl);
            this.previewContainer.appendChild(answerEl);
            this.previewContainer.appendChild(instruction);

            // Animate in
            setTimeout(() => {
                croppedImg.style.opacity = '1';
                questionEl.style.opacity = '1';
            }, 100);

            // Click to reveal
            let revealed = false;
            const reveal = () => {
                if (revealed) return;
                revealed = true;
                instruction.style.display = 'none';

                // Calculate transform for cropped to full position
                const fullLeft = (window.innerWidth - img.width * fullScale) / 2;
                const fullTop = (window.innerHeight - img.height * fullScale) / 2;

                const targetX = fullLeft + sel.x * fullScale;
                const targetY = fullTop + sel.y * fullScale;
                const targetScale = fullScale / croppedScale;

                const croppedRect = croppedImg.getBoundingClientRect();
                const translateX = targetX - croppedRect.left;
                const translateY = targetY - croppedRect.top;

                croppedImg.style.transform = `translate(${translateX}px, ${translateY}px) scale(${targetScale})`;
                croppedImg.style.transformOrigin = 'top left';

                questionEl.style.opacity = '0';

                setTimeout(() => {
                    fullImg.style.opacity = '1';
                }, 400);

                setTimeout(() => {
                    answerEl.style.opacity = '1';
                }, 1200);
            };

            croppedImg.addEventListener('click', reveal);
            this.previewContainer.addEventListener('click', reveal);
        };
    }

    closePreview() {
        this.previewModal.classList.remove('visible');
        this.previewContainer.innerHTML = '';
    }

    async saveProject() {
        if (this.images.length === 0) {
            alert('No images to save. Please add some images first.');
            return;
        }

        const projectData = {
            version: 1,
            projectName: this.projectName.value || 'Untitled Project',
            gameTitle: this.gameTitle.value,
            gameExplanation: this.gameExplanation.value,
            nextButtonLabel: this.nextButtonLabel.value,
            progressLabel: this.progressLabel.value,
            completionMessage: this.completionMessage.value,
            images: this.images.map((img, index) => ({
                index,
                name: img.name,
                selection: img.selection,
                question: img.question,
                questionSize: img.questionSize,
                answer: img.answer,
                answerSize: img.answerSize,
                answerColor: img.answerColor,
                answerOutline: img.answerOutline,
                answerPosition: img.answerPosition
            }))
        };

        const zip = new JSZip();
        zip.file('project.json', JSON.stringify(projectData, null, 2));

        const imagesFolder = zip.folder('images');
        for (const image of this.images) {
            const base64 = image.dataUrl.split(',')[1];
            imagesFolder.file(image.name, base64, { base64: true });
        }

        const blob = await zip.generateAsync({ type: 'blob' });
        const filename = (this.projectName.value || 'project') + '.zip';
        this.downloadBlob(blob, filename);
    }

    async loadProject(file) {
        if (!file) return;

        try {
            const zip = await JSZip.loadAsync(file);
            const projectJson = await zip.file('project.json').async('text');
            const projectData = JSON.parse(projectJson);

            // Clear current state
            this.images = [];
            this.currentIndex = -1;

            // Load settings
            this.projectName.value = projectData.projectName || '';
            this.gameTitle.value = projectData.gameTitle || '';
            this.gameExplanation.value = projectData.gameExplanation || '';
            this.nextButtonLabel.value = projectData.nextButtonLabel || '';
            this.progressLabel.value = projectData.progressLabel || '';
            this.completionMessage.value = projectData.completionMessage || '';
            this.updateProjectName();

            // Load images
            const imagePromises = projectData.images.map(async (imgData) => {
                const imageFile = zip.file('images/' + imgData.name);
                if (!imageFile) return null;

                const base64 = await imageFile.async('base64');
                const ext = imgData.name.split('.').pop().toLowerCase();
                const mimeType = ext === 'png' ? 'image/png' :
                               ext === 'gif' ? 'image/gif' :
                               ext === 'webp' ? 'image/webp' : 'image/jpeg';
                const dataUrl = `data:${mimeType};base64,${base64}`;

                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => {
                        resolve({
                            id: Date.now() + Math.random(),
                            name: imgData.name,
                            dataUrl: dataUrl,
                            width: img.width,
                            height: img.height,
                            selection: imgData.selection,
                            question: imgData.question,
                            questionSize: imgData.questionSize,
                            answer: imgData.answer,
                            answerSize: imgData.answerSize,
                            answerColor: imgData.answerColor,
                            answerOutline: imgData.answerOutline,
                            answerPosition: imgData.answerPosition
                        });
                    };
                    img.src = dataUrl;
                });
            });

            const loadedImages = await Promise.all(imagePromises);
            this.images = loadedImages.filter(img => img !== null);

            if (this.images.length > 0) {
                this.currentIndex = 0;
            }

            this.updateUI();
            this.renderGallery();

            alert('Project loaded successfully!');
        } catch (error) {
            console.error('Error loading project:', error);
            alert('Error loading project. Please make sure the file is a valid ImagePuzzler project.');
        }

        this.loadProjectInput.value = '';
    }

    generateGame() {
        if (this.images.length === 0) {
            alert('No images to generate a game. Please add some images first.');
            return;
        }

        // Check if all images have selections
        const missingSelections = this.images.filter(img => !img.selection);
        if (missingSelections.length > 0) {
            alert(`Please draw selection rectangles on all images. ${missingSelections.length} image(s) are missing selections.`);
            return;
        }

        const gameData = {
            title: this.gameTitle.value || this.projectName.value || 'Image Quiz',
            explanation: this.gameExplanation.value || 'Look at the cropped image and guess what it is. Click to reveal the answer!',
            nextButtonLabel: this.nextButtonLabel.value,
            progressLabel: this.progressLabel.value,
            completionMessage: this.completionMessage.value || 'Congratulations! You\'ve completed the quiz.',
            images: this.images.map(img => ({
                dataUrl: img.dataUrl,
                width: img.width,
                height: img.height,
                selection: img.selection,
                question: img.question || 'What is this?',
                questionSize: img.questionSize || 72,
                answer: img.answer || '',
                answerSize: img.answerSize || 72,
                answerColor: img.answerColor || '#ffffff',
                answerOutline: img.answerOutline !== false,
                answerPosition: img.answerPosition || { x: 50, y: 50 }
            }))
        };

        const html = this.generateGameHTML(gameData);
        const blob = new Blob([html], { type: 'text/html' });
        const filename = (this.projectName.value || 'game') + '.html';
        this.downloadBlob(blob, filename);
    }

    generateGameHTML(data) {
        return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${this.escapeHtml(data.title)}</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        .screen { display: none; width: 100%; height: 100vh; }
        .screen.active { display: flex; align-items: center; justify-content: center; }

        .start-card, .end-card {
            background: white;
            border-radius: 20px;
            padding: 40px 60px;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            max-width: 500px;
        }
        .start-card h1, .end-card h1 {
            color: #667eea;
            font-size: 2.5rem;
            margin-bottom: 20px;
        }
        .start-card p, .end-card p {
            color: #666;
            font-size: 1.1rem;
            line-height: 1.6;
            margin-bottom: 30px;
        }
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.2rem;
            font-weight: 600;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(102,126,234,0.4); }

        .game-screen { flex-direction: column; position: relative; }
        .progress {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            color: #667eea;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        .cropped-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            opacity: 0;
            transition: opacity 0.4s;
        }
        .cropped-container.visible { opacity: 1; }
        .cropped-img {
            max-width: 75vw;
            max-height: 60vh;
            object-fit: contain;
            cursor: pointer;
            transition: transform 1.2s ease-in-out, opacity 0.4s;
        }
        .question-text {
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            margin-top: 20px;
            text-align: center;
            transition: opacity 0.4s;
        }
        .full-container {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .full-img {
            max-width: 90vw;
            max-height: 90vh;
            object-fit: contain;
            opacity: 0;
            transition: opacity 1s;
        }
        .full-img.visible { opacity: 1; }
        .answer-text {
            position: absolute;
            opacity: 0;
            transition: opacity 0.8s;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            white-space: nowrap;
        }
        .answer-text.visible { opacity: 1; }
        .instruction {
            position: absolute;
            bottom: 40px;
            color: white;
            font-size: 1.25rem;
            opacity: 0.8;
            animation: pulse 2s infinite;
        }
        .next-btn {
            position: absolute;
            bottom: 40px;
            opacity: 0;
            transition: opacity 0.4s;
            pointer-events: none;
        }
        .next-btn.visible { opacity: 1; pointer-events: auto; }
        @keyframes pulse { 0%, 100% { opacity: 0.6; } 50% { opacity: 1; } }
    </style>
</head>
<body>
    <div class="screen start-screen active" id="start-screen">
        <div class="start-card">
            <h1>${this.escapeHtml(data.title)}</h1>
            <p>${this.escapeHtml(data.explanation)}</p>
            <button class="btn" onclick="startGame()">Start Game</button>
        </div>
    </div>

    <div class="screen game-screen" id="game-screen">
        ${data.progressLabel ? '<div class="progress" id="progress"></div>' : ''}
        <div class="full-container">
            <img class="full-img" id="full-img">
            <div class="answer-text" id="answer-text"></div>
        </div>
        <div class="cropped-container" id="cropped-container">
            <img class="cropped-img" id="cropped-img" onclick="reveal()">
            <div class="question-text" id="question-text"></div>
        </div>
        <div class="instruction" id="instruction">Click to reveal</div>
        ${data.nextButtonLabel ? `<button class="btn next-btn" id="next-btn" onclick="nextQuestion()">${this.escapeHtml(data.nextButtonLabel)}</button>` : ''}
    </div>

    <div class="screen end-screen" id="end-screen">
        <div class="end-card">
            <h1>Game Complete!</h1>
            <p>${this.escapeHtml(data.completionMessage)}</p>
            <button class="btn" onclick="restartGame()">Play Again</button>
        </div>
    </div>

    <script>
        const gameData = ${JSON.stringify(data.images)};
        const progressLabel = ${JSON.stringify(data.progressLabel)};
        const hasNextButton = ${!!data.nextButtonLabel};

        let currentIndex = 0;
        let revealed = false;
        let canAdvance = false;

        function showScreen(id) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(id).classList.add('active');
        }

        function startGame() {
            currentIndex = 0;
            showScreen('game-screen');
            loadQuestion();
        }

        function restartGame() {
            startGame();
        }

        function loadQuestion() {
            revealed = false;
            canAdvance = false;

            const q = gameData[currentIndex];
            const croppedContainer = document.getElementById('cropped-container');
            const croppedImg = document.getElementById('cropped-img');
            const questionText = document.getElementById('question-text');
            const fullImg = document.getElementById('full-img');
            const answerText = document.getElementById('answer-text');
            const instruction = document.getElementById('instruction');
            const nextBtn = document.getElementById('next-btn');
            const progress = document.getElementById('progress');

            // Reset states
            croppedContainer.classList.remove('visible');
            croppedImg.style.transform = '';
            questionText.style.opacity = '1';
            fullImg.classList.remove('visible');
            answerText.classList.remove('visible');
            instruction.style.display = 'block';
            if (nextBtn) nextBtn.classList.remove('visible');

            // Update progress
            if (progress && progressLabel) {
                progress.textContent = progressLabel
                    .replace('{current}', currentIndex + 1)
                    .replace('{total}', gameData.length);
            }

            // Create cropped image
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                canvas.width = q.selection.width;
                canvas.height = q.selection.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, q.selection.x, q.selection.y, q.selection.width, q.selection.height, 0, 0, q.selection.width, q.selection.height);
                croppedImg.src = canvas.toDataURL();

                // Set question
                questionText.textContent = q.question;
                questionText.style.fontSize = q.questionSize + 'px';

                // Set full image
                fullImg.src = q.dataUrl;

                // Set answer
                answerText.textContent = q.answer;
                answerText.style.fontSize = q.answerSize + 'px';
                answerText.style.color = q.answerColor;
                answerText.style.webkitTextStroke = q.answerOutline ? '2px black' : 'none';
                answerText.style.left = q.answerPosition.x + '%';
                answerText.style.top = q.answerPosition.y + '%';
                answerText.style.transform = 'translate(-50%, -50%)';

                // Show cropped container
                setTimeout(() => croppedContainer.classList.add('visible'), 50);
            };
            img.src = q.dataUrl;
        }

        function reveal() {
            if (revealed) {
                if (canAdvance && !hasNextButton) nextQuestion();
                return;
            }
            revealed = true;

            const q = gameData[currentIndex];
            const croppedImg = document.getElementById('cropped-img');
            const questionText = document.getElementById('question-text');
            const fullImg = document.getElementById('full-img');
            const answerText = document.getElementById('answer-text');
            const instruction = document.getElementById('instruction');
            const nextBtn = document.getElementById('next-btn');

            instruction.style.display = 'none';

            // Calculate transform
            const croppedRect = croppedImg.getBoundingClientRect();
            const fullScale = Math.min(
                (window.innerWidth * 0.9) / q.width,
                (window.innerHeight * 0.9) / q.height,
                1
            );
            const croppedScale = croppedRect.width / q.selection.width;

            const fullWidth = q.width * fullScale;
            const fullHeight = q.height * fullScale;
            const fullLeft = (window.innerWidth - fullWidth) / 2;
            const fullTop = (window.innerHeight - fullHeight) / 2;

            const targetX = fullLeft + q.selection.x * fullScale;
            const targetY = fullTop + q.selection.y * fullScale;
            const targetScale = fullScale / croppedScale;

            const translateX = targetX - croppedRect.left;
            const translateY = targetY - croppedRect.top;

            croppedImg.style.transformOrigin = 'top left';
            croppedImg.style.transform = \`translate(\${translateX}px, \${translateY}px) scale(\${targetScale})\`;
            questionText.style.opacity = '0';

            setTimeout(() => fullImg.classList.add('visible'), 400);
            setTimeout(() => {
                answerText.classList.add('visible');
                canAdvance = true;
                if (hasNextButton && nextBtn) nextBtn.classList.add('visible');
            }, 1200);
        }

        function nextQuestion() {
            if (!canAdvance) return;
            currentIndex++;
            if (currentIndex >= gameData.length) {
                showScreen('end-screen');
            } else {
                loadQuestion();
            }
        }

        // Click anywhere to advance (if no next button)
        document.getElementById('game-screen').addEventListener('click', (e) => {
            if (!hasNextButton && canAdvance && revealed && e.target.id !== 'cropped-img') {
                nextQuestion();
            }
        });
    <\/script>
</body>
</html>`;
    }

    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    downloadBlob(blob, filename) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    resetAll() {
        if (!confirm('Are you sure you want to reset everything? This cannot be undone.')) {
            return;
        }

        this.images = [];
        this.currentIndex = -1;

        this.projectName.value = '';
        this.gameTitle.value = '';
        this.gameExplanation.value = '';
        this.nextButtonLabel.value = '';
        this.progressLabel.value = '';
        this.completionMessage.value = '';

        this.updateProjectName();
        this.updateUI();
        this.renderGallery();
    }
}

// Initialize app
document.addEventListener('DOMContentLoaded', () => {
    window.app = new ImagePuzzler();
});
    </script>
</body>
</html>
